# 概述

- 协程是一种用户态的轻量级线程。
	- 轻量级：相对于线程而言，协程比较轻量。在一个服务器上线程的数量不能太多，也就是上百个线程的级别，否则会产生性能问题。而协程可以轻松达到达到百万级别。
	- 协作式：协程是用户态的概念，对操作系统无感知。操作系统感知不到协程的存在，只能感知到线程和进程的存在。协程的调度是在用户态自己调度。一般协程的调度是协作式的调度。
- 根据控制传递机制的不同区分出了对称协程和非对称协程。
	- 非对称协程知道它的调用者，其在挂起时转让控制权给它的调用者，然后调用者根据算法调用其他非对称协程进行工作。具体来讲，非对称协程是跟一个特定的调用者绑定的，协程让出 CPU 时，只能让回给原调用者。那到底是什么东西“不对称”呢？其实，非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。
	- 对称协程都是等价的，控制权直接在对称协程之间进行传递，即对称协程在挂起时主动指明另外一个对称协程来接收控制权。对称协程与非对称协程不一样，启动之后就跟启动之前的协程没有任何关系了。协程的切换操作，一般而言只有一个操作，yield，用于将程序控制流转移给另外的协程。对称协程机制一般需要一个调度器的支持，按一定调度算法去选择 yield 的目标协程。
- sylar 的协程模块是基于 ucontext.h 实现的非对称协程库。结构体 ucontext_t 保存了程序当前运行的上下文，例如寄存器信息（这些寄存器记录了函数栈帧、代码的执行位置等信息）等。
- ucontext_t 结构体与具体平台相关，但至少会有以下四个成员：
	```C
	ucontext_t *uc_link     	// Pointer to the context that is resumed when this context returns. 
	sigset_t    uc_sigmask  	// The set of signals that are blocked when this context is active. 
	stack_t     uc_stack    	// The stack used by this context. 
	mcontext_t  uc_mcontext  	// A machine-specific representation of the saved context. 
  ```
- ucontext.h 还提供了以下四个函数：
	```C
	int getcontext(ucontext_t *ucp);
	- 获取当前上下文
	
	int setcontext(const ucontext_t *ucp);
	- 恢复 ucp 指向的上下文，但这个函数不会返回，而是会跳转到 ucp 上下文对应的函数中执行，相当于变相调用了函数。
	
	void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);
	- 修改由 getcontext 获取到的上下文指针 ucp，将其与一个函数 func 进行绑定，支持指定 func 运行时的参数。
	- 在调用 makecontext 之前，必须手动给 ucp 分配一段内存空间，存储在 ucp->uc_stack 中，这段内存空间将作为 func 函数运行时的栈空间。
	- 同时也可以指定 ucp->uc_link，表示函数运行结束后恢复 uc_link 指向的上下文。
	- 如果不赋值 uc_link，那 func 函数结束时必须调用 setcontext 或 swapcontext 以重新指定一个有效的上下文，否则程序就跑飞了。
	- makecontext 执行完后，ucp 就与函数 func 绑定了，调用 setcontext 或 swapcontext 激活 ucp 时，func 就会被运行。
	
	int swapcontext(ucontext_t *restrict oucp, const ucontext_t *restrict ucp);
	- 恢复 ucp 指向的上下文，同时将当前的上下文存储到 oucp 中。
	- 和 setcontext 一样，swapcontext 也不会返回，而是会跳转到 ucp 上下文对应的函数中执行，相当于调用了函数。
	- swapcontext 是 sylar 非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换。
	```
- 协程与 IO 多路复用结合，成为高并发的解决方案。


# Fiber

- 协程类。


# 其他说明

- 因为单线程下协程并不是并发执行，而是顺序执行的，所以不要在协程里使用线程级别的锁来做协程同步，比如 pthread_mutex_t。如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。
- 对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是 resume，表示恢复协程运行，一种是 yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次 yield 以返回主协程。
- 单线程环境下，协程的 yield 和 resume 一定是同步进行的，一个协程的 yield，必然对应另一个协程的 resume，因为线程不可能没有执行主体。并且，协程的 yield 和 resume 是完全由应用程序来控制的。
- 所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。
- sylar 借助了线程局部变量的功能来实现协程模块。对于每个线程的协程上下文，sylar 设计了两个线程局部变量来存储上下文信息（对应源码的 t_fiber 和 t_thread_fiber），也就是说，一个线程在任何时候最多只能知道两个协程的上下文。又由于 sylar 只使用 swapcontext 来做协程切换，那就意味着，这两个线程局部变量必须至少有一个是用来保存线程主协程的上下文的，如果这两个线程局部变量存储的都是子协程的上下文，那么不管怎么调用 swapcontext，都没法恢复主协程的上下文，也就意味着程序最终无法回到主协程去执行，程序也就跑飞了。
- READY 状态的协程会被调度器自动重新调度，而 HOLD 状态的协程需要显式地再次将协程加入调度。
- 因为 GetThis() 兼具初始化主协程的功能，在使用协程之前必须显式调用一次 GetThis()。
- 线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有 ucontext_t 上下文，但没有入口函数，也没有分配栈空间。
- 非对称协程，子协程不能创建并运行新的子协程，不然程序就跑飞了。
